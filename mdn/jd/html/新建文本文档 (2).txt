#include "pfm.h"
#include "qx_ppm.h"
#include "qx_basic.h"
#include "qx_nonlocal_cost_aggregation.h"
#include <iostream>
#include <fstream>
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
using namespace std;
// best test
//#define QX_DEF_SIGMA							0.01//0.1
#define QX_DEF_SIGMA							0.01

IplImage *msk;
char* path;
char* cnn_fst_path;
int max_disparity;
int disparity_offset;
char* cnn_path0;
char* cnn_path1;
char* cnn_path2;
char* cnn_path3;
char* cnn_path4;
char* outliers_path;
char* tree_path;
void stereo(char*filename_disparity_map, char*filename_left_image, char*filename_right_image, int max_disparity, int disparity_offset, bool use_post_processing)
{
	double sigma = QX_DEF_SIGMA;
	unsigned char***left, ***right, **disparity;
	int h, w;
	float* disparity1, *disp_l;

	qx_image_size(filename_left_image, h, w);//obtain image size
	cout << "h = " << h << "   w = " << w << endl;

	left = qx_allocu_3(h, w, 3);//allocate memory
	right = qx_allocu_3(h, w, 3);
	disparity = qx_allocu(h, w);
	disparity1 = (float*)malloc(sizeof(float)*(w * h));
	disp_l = (float*)malloc(sizeof(float)*(w * h));

	qx_nonlocal_cost_aggregation m_nlca;//non-local cost aggregation class
	m_nlca.init(h, w, max_disparity, disparity_offset, sigma);//initialization

	qx_loadimage(filename_left_image, left[0][0], h, w);//load left image
	qx_loadimage(filename_right_image, right[0][0], h, w);//load right image

	qx_timer timer;
	timer.start();

	//m_nlca.matching_cost(left, right);//compute matching cost
	timer.time_display("Matching cost computation");

	timer.start();
	m_nlca.disparity1(disparity1, disp_l, use_post_processing);//compute disparity
	if (use_post_processing) timer.time_display("Non-local cost aggregation (including non-local post processing)");
	else timer.time_display("Non-local cost aggregation (excluding non-local post processing)");

	//for (int y = 0; y < h; y++) for (int x = 0; x < w; x++) disparity[y][x] *= 256 / max_disparity;//rescale the disparity map for visualization
	//for (int y = 0; y < h; y++) for (int x = 0; x < w; x++) disparity1[x + y * w] *= 256 / max_disparity;//rescale the disparity map for visualization
	//qx_saveimage(filename_disparity_map, disparity[0], h, w, 1);//write the obtained disparity map to the harddrive
	//qx_saveimage(filename_disparity_map, disparity1, h, w, 1);//write the obtained disparity map to the harddrive

	ofstream disp("disparity.txt");
	for (int y = 0; y < h; y++)
	{
		for (int x = 0; x < w; x++)
		{
			disp << disparity1[x + y * w] << " ";
		}		
		disp << endl;
	}
	disp.close();
	// draw
	IplImage* img = NULL;
	img = cvCreateImage(cvSize(w, h), 8, 1);
	for (int y = 0; y < h; y++)
	{
		for (int x = 0; x < w; x++)
			cvSet2D(img, y, x, cvScalar(disparity1[x + y * w]));
	}
	//cvNamedWindow("Image", 1);
	//cvShowImage("Image", img);
	remove("img.jpg");
    cvSaveImage("img.jpg", img);

	qx_freeu_3(left); left = NULL;//free memory
	qx_freeu_3(right); right = NULL;
	qx_freeu(disparity); disparity = NULL;

	// computing the error rate
	/*IplImage *msk = cvLoadImage("D:\\Stereo Matching\\MiddEval3-GT0-H\\MiddEval3\\trainingH\\Motorcycle\\mask0nocc.png", -1);
	char* path = "D:\\Stereo Matching\\MiddEval3-GT0-H\\MiddEval3\\trainingH\\Motorcycle\\disp0GT.pfm";
	char* cnn_fst_path = "D:\\Stereo Matching\\results_MC-CNN-fst_H\\trainingH\\Motorcycle\\disp0MC-CNN-fst.pfm";*/

	PFM pfm_rw;
	PFM cnn_fst_rw;
	float* p_disp_gt = pfm_rw.read_pfm<float>(path);
	float* cnn_fst = cnn_fst_rw.read_pfm<float>(cnn_fst_path);
	// test the best occasions
	draw_differences(disp_l, disparity1, p_disp_gt, msk, h, w);
	//compute_error_rate(disp_l, p_disp_gt, msk, h, w);
	//draw_error_pixels(disp_l, p_disp_gt, msk, h, w, "local");
	//compute_error_rate(cnn_fst, p_disp_gt, msk, h, w);
	//draw_error_pixels(cnn_fst, p_disp_gt, msk, h, w, "cnn");
	compute_error_rate(disparity1, p_disp_gt, msk, h, w);
	draw_error_pixels(disparity1, p_disp_gt, msk, h, w, "disp");	
	//draw_error_pixels(disp_l, p_disp_gt, msk, h, w, "local");
}
int main(int argc, char*argv[])
{
	/*if(argc!=5)
	{
	printf("Usage:\n");
	printf("*.exe: filename_disparity_map filename_left_image filename_right_image max_disparity\n");
	return(-1);
	}*/
	//argv[0] = "qx_nonlocal_cost_aggregation.exe";

	char*filename_disparity_map = "D:\\Mid3\\tree_filter.pgm";	

	/*char*filename_left_image = "D:\\Stereo Matching\\MiddEval3-data-H\\MiddEval3\\trainingH\\Motorcycle\\im0.ppm";
	char*filename_right_image = "D:\\Stereo Matching\\MiddEval3-data-H\\MiddEval3\\trainingH\\Motorcycle\\im1.ppm";
	int max_disparity = 140, disparity_offset = 0;*/

	char*filename_left_image = argv[1];
	char*filename_right_image = argv[2];
	msk = cvLoadImage(argv[3], -1);
	path = argv[4];
	cnn_fst_path = argv[5];
	max_disparity = atoi(argv[6]);
	disparity_offset = atoi(argv[7]);
	cnn_path0 = argv[8];
	cnn_path1 = argv[9];
	cnn_path2 = argv[10];
	cnn_path3 = argv[11];
	cnn_path4 = argv[12];
	outliers_path = argv[13];
	tree_path = argv[14];

	srand((unsigned)time(NULL));
	
	stereo(filename_disparity_map,filename_left_image,filename_right_image,max_disparity, disparity_offset, false);//excluding non-local post processing
	//stereo(filename_disparity_map, filename_left_image, filename_right_image, max_disparity, disparity_offset, true);//including non-local post processing
	system("pause");
	return(0);
}