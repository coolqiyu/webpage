#include "qx_basic.h"

#include <windows.h>//The win32 API library
#include <algorithm>
#include <vector>
#include <fstream>
#include <string>
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
using namespace std;
extern char* outliers_path;
/*timer*/
void qx_timer::start()
{
	//m_begin=clock();

	LARGE_INTEGER li;
	if (!QueryPerformanceFrequency(&li))
		cout << "QueryPerformanceFrequency failed!\n";

	m_pc_frequency = double(li.QuadPart);///1000.0;

	QueryPerformanceCounter(&li);
	m_counter_start = li.QuadPart;
}
double qx_timer::stop()
{
	//m_end=clock(); return ( double(m_end-m_begin)/CLOCKS_PER_SEC );
	LARGE_INTEGER li;
	QueryPerformanceCounter(&li);
	return double(li.QuadPart - m_counter_start) / m_pc_frequency;
}
void qx_timer::time_display(char *disp, int nr_frame){ printf("Running time (%s) is: %5.5f Seconds.\n", disp, stop() / nr_frame); }
void qx_timer::fps_display(char *disp, int nr_frame){ printf("Running time (%s) is: %5.5f frame per second.\n", disp, (double)nr_frame / stop()); }
void boxcar_sliding_window_x(double *out, double *in, int h, int w, int radius)
{
	double scale = 1.0f / (2 * radius + 1);
	for (int y = 0; y < h; y++) {
		double t;
		// do left edge
		t = in[y*w] * radius;
		for (int x = 0; x < radius + 1; x++) {
			t += in[y*w + x];
		}
		out[y*w] = t * scale;
		for (int x = 1; x < radius + 1; x++) {
			int c = y*w + x;
			t += in[c + radius];
			t -= in[y*w];
			out[c] = t * scale;
		}
		// main loop
		for (int x = radius + 1; x < w - radius; x++) {
			int c = y*w + x;
			t += in[c + radius];
			t -= in[c - radius - 1];
			out[c] = t * scale;
		}
		// do right edge
		for (int x = w - radius; x < w; x++) {
			int c = y*w + x;
			t += in[(y*w) + w - 1];
			t -= in[c - radius - 1];
			out[c] = t * scale;
		}

	}
}
void boxcar_sliding_window_y(double *out, double *in, int h, int w, int radius)
{
	double scale = 1.0f / (2 * radius + 1);
	for (int x = 0; x < w; x++)
	{
		double t;
		// do left edge
		t = in[x] * radius;
		for (int y = 0; y < radius + 1; y++) {
			t += in[y*w + x];
		}
		out[x] = t * scale;
		for (int y = 1; y < radius + 1; y++) {
			int c = y*w + x;
			t += in[c + radius*w];
			t -= in[x];
			out[c] = t * scale;
		}
		// main loop
		for (int y = radius + 1; y < h - radius; y++) {
			int c = y*w + x;
			t += in[c + radius*w];
			t -= in[c - (radius*w) - w];
			out[c] = t * scale;
		}
		// do right edge
		for (int y = h - radius; y < h; y++) {
			int c = y*w + x;
			t += in[(h - 1)*w + x];
			t -= in[c - (radius*w) - w];
			out[c] = t * scale;
		}
	}
}
void boxcar_sliding_window(double **out, double **in, double **temp, int h, int w, int radius)
{
	boxcar_sliding_window_x(temp[0], in[0], h, w, radius);
	boxcar_sliding_window_y(out[0], temp[0], h, w, radius);
}

void boxcar_sliding_window_x(float *out, float *in, int h, int w, int radius)
{
	float scale = 1.0f / (2 * radius + 1);
	for (int y = 0; y < h; y++) {
		float t;
		// do left edge
		t = in[y*w] * radius;
		for (int x = 0; x < radius + 1; x++) {
			t += in[y*w + x];
		}
		out[y*w] = t * scale;
		for (int x = 1; x < radius + 1; x++) {
			int c = y*w + x;
			t += in[c + radius];
			t -= in[y*w];
			out[c] = t * scale;
		}
		// main loop
		for (int x = radius + 1; x < w - radius; x++) {
			int c = y*w + x;
			t += in[c + radius];
			t -= in[c - radius - 1];
			out[c] = t * scale;
		}
		// do right edge
		for (int x = w - radius; x < w; x++) {
			int c = y*w + x;
			t += in[(y*w) + w - 1];
			t -= in[c - radius - 1];
			out[c] = t * scale;
		}

	}
}
void boxcar_sliding_window_y(float *out, float *in, int h, int w, int radius)
{
	float scale = 1.0f / (2 * radius + 1);
	for (int x = 0; x < w; x++)
	{
		float t;
		// do left edge
		t = in[x] * radius;
		for (int y = 0; y < radius + 1; y++) {
			t += in[y*w + x];
		}
		out[x] = t * scale;
		for (int y = 1; y < radius + 1; y++) {
			int c = y*w + x;
			t += in[c + radius*w];
			t -= in[x];
			out[c] = t * scale;
		}
		// main loop
		for (int y = radius + 1; y < h - radius; y++) {
			int c = y*w + x;
			t += in[c + radius*w];
			t -= in[c - (radius*w) - w];
			out[c] = t * scale;
		}
		// do right edge
		for (int y = h - radius; y < h; y++) {
			int c = y*w + x;
			t += in[(h - 1)*w + x];
			t -= in[c - (radius*w) - w];
			out[c] = t * scale;
		}
	}
}
void boxcar_sliding_window(float**out, float**in, float**temp, int h, int w, int radius)
{
	int min_hw = min(h, w);
	if (radius >= min_hw)
	{
		double dsum = 0;
		float*in_ = in[0];
		for (int y = 0; y < h; y++) for (int x = 0; x < w; x++) dsum += *in_++;
		dsum /= (h*w);
		float fsum = (float)dsum;
		float*out_ = out[0];
		for (int y = 0; y < h; y++) for (int x = 0; x<w; x++) *out_++ = fsum;
	}
	else if (radius>0)
	{
		boxcar_sliding_window_x(temp[0], in[0], h, w, radius);
		boxcar_sliding_window_y(out[0], temp[0], h, w, radius);
	}
	else memcpy(out[0], in[0], sizeof(float)*h*w);
}
void boxcar_sliding_window_x(unsigned char*out, unsigned char*in, int h, int w, int radius)
{
	float scale = 1.0f / (2 * radius + 1);
	for (int y = 0; y < h; y++) {
		float t;
		// do left edge
		t = in[y*w] * radius;
		for (int x = 0; x < radius + 1; x++) {
			t += in[y*w + x];
		}
		out[y*w] = unsigned char(t * scale + 0.5);
		for (int x = 1; x < radius + 1; x++) {
			int c = y*w + x;
			t += in[c + radius];
			t -= in[y*w];
			out[c] = unsigned char(t * scale + 0.5);
		}
		// main loop
		for (int x = radius + 1; x < w - radius; x++) {
			int c = y*w + x;
			t += in[c + radius];
			t -= in[c - radius - 1];
			out[c] = unsigned char(t * scale + 0.5);
		}
		// do right edge
		for (int x = w - radius; x < w; x++) {
			int c = y*w + x;
			t += in[(y*w) + w - 1];
			t -= in[c - radius - 1];
			out[c] = unsigned char(t * scale + 0.5);
		}

	}
}
void boxcar_sliding_window_y(unsigned char*out, unsigned char*in, int h, int w, int radius)
{
	float scale = 1.0f / (2 * radius + 1);
	for (int x = 0; x < w; x++)
	{
		float t;
		// do left edge
		t = in[x] * radius;
		for (int y = 0; y < radius + 1; y++) {
			t += in[y*w + x];
		}
		out[x] = unsigned char(t * scale + 0.5);
		for (int y = 1; y < radius + 1; y++) {
			int c = y*w + x;
			t += in[c + radius*w];
			t -= in[x];
			out[c] = unsigned char(t * scale + 0.5);
		}
		// main loop
		for (int y = radius + 1; y < h - radius; y++) {
			int c = y*w + x;
			t += in[c + radius*w];
			t -= in[c - (radius*w) - w];
			out[c] = unsigned char(t * scale + 0.5);
		}
		// do right edge
		for (int y = h - radius; y < h; y++) {
			int c = y*w + x;
			t += in[(h - 1)*w + x];
			t -= in[c - (radius*w) - w];
			out[c] = unsigned char(t * scale + 0.5);
		}
	}
}
void boxcar_sliding_window(unsigned char**out, unsigned char**in, unsigned char**temp, int h, int w, int radius)
{
	int min_hw = min(h, w);
	if (radius < min_hw)
	{
		boxcar_sliding_window_x(temp[0], in[0], h, w, radius);
		boxcar_sliding_window_y(out[0], temp[0], h, w, radius);
	}
	else
	{
		double dsum = 0;
		unsigned char*in_ = in[0];
		for (int y = 0; y < h; y++) for (int x = 0; x < w; x++) dsum += *in_++;
		dsum /= (h*w);
		unsigned char usum = unsigned char(dsum + 0.5);
		unsigned char*out_ = out[0];
		for (int y = 0; y < h; y++) for (int x = 0; x < w; x++) *out_++ = usum;
	}
}
void gaussian_recursive_x(double **od, double **id, int w, int h, double a0, double a1, double a2, double a3, double b1, double b2, double coefp, double coefn)
{
	double xp = 0.0f;  // previous input
	double yp = 0.0f;  // previous output
	double yb = 0.0f;  // previous output by 2
	for (int y = 0; y < h; y++)
	{
		xp = id[y][0]; yb = coefp*xp; yp = yb;
		for (int x = 0; x < w; x++)
		{
			double xc = id[y][x];
			double yc = a0*xc + a1*xp - b1*yp - b2*yb;
			od[y][x] = yc;
			xp = xc; yb = yp; yp = yc;
		}
	}
	// reverse pass
	// ensures response is symmetrical
	double xn = 0.f;
	double xa = 0.f;
	double yn = 0.f;
	double ya = 0.f;
	for (int y = 0; y < h; y++)
	{
		xn = xa = id[y][w - 1]; yn = coefn*xn; ya = yn;
		for (int x = w - 1; x >= 0; x--) {
			double xc = id[y][x];
			double yc = a2*xn + a3*xa - b1*yn - b2*ya;
			xa = xn; xn = xc; ya = yn; yn = yc;
			od[y][x] = od[y][x] + yc;
		}
	}
}
void gaussian_recursive_y(double **od, double **id, int w, int h, double a0, double a1, double a2, double a3, double b1, double b2, double coefp, double coefn)
{
	double xp = 0.0f;  // previous input
	double yp = 0.0f;  // previous output
	double yb = 0.0f;  // previous output by 2
	for (int x = 0; x < w; x++)
	{
		xp = id[0][x]; yb = coefp*xp; yp = yb;
		for (int y = 0; y < h; y++)
		{
			double xc = id[y][x];
			double yc = a0*xc + a1*xp - b1*yp - b2*yb;
			od[y][x] = yc;
			xp = xc; yb = yp; yp = yc;
		}
	}


	// reverse pass
	// ensures response is symmetrical
	double xn = 0.f;
	double xa = 0.f;
	double yn = 0.f;
	double ya = 0.f;
	for (int x = 0; x < w; x++)
	{
		xn = xa = id[h - 1][x]; yn = coefn*xn; ya = yn;
		for (int y = h - 1; y >= 0; y--)
		{
			double xc = id[y][x];
			double yc = a2*xn + a3*xa - b1*yn - b2*ya;
			xa = xn; xn = xc; ya = yn; yn = yc;
			od[y][x] = od[y][x] + yc;
		}
	}
}
int gaussian_recursive(double **image, double **temp, double sigma, int order, int h, int w)
{
	const double
		nsigma = sigma < 0.1f ? 0.1f : sigma,
		alpha = 1.695f / nsigma,
		ema = exp(-alpha),
		ema2 = exp(-2 * alpha),
		b1 = -2 * ema,
		b2 = ema2;
	double a0 = 0, a1 = 0, a2 = 0, a3 = 0, coefp = 0, coefn = 0;
	switch (order) {
	case 0: {
				const double k = (1 - ema)*(1 - ema) / (1 + 2 * alpha*ema - ema2);
				a0 = k;
				a1 = k*(alpha - 1)*ema;
				a2 = k*(alpha + 1)*ema;
				a3 = -k*ema2;
	} break;

	case 1: {
				const double k = (1 - ema)*(1 - ema) / ema;
				a0 = k*ema;
				a1 = a3 = 0;
				a2 = -a0;
	} break;

	case 2: {
				const double
					ea = exp(-alpha),
					k = -(ema2 - 1) / (2 * alpha*ema),
					kn = (-2 * (-1 + 3 * ea - 3 * ea*ea + ea*ea*ea) / (3 * ea + 1 + 3 * ea*ea + ea*ea*ea));
				a0 = kn;
				a1 = -kn*(1 + k*alpha)*ema;
				a2 = kn*(1 - k*alpha)*ema;
				a3 = -kn*ema2;
	} break;

	default:
		fprintf(stderr, "gaussianFilter: invalid order parameter!\n");
		return 0;
	}
	coefp = (a0 + a1) / (1 + b1 + b2);
	coefn = (a2 + a3) / (1 + b1 + b2);
	//timer.start();
	gaussian_recursive_x(temp, image, w, h, a0, a1, a2, a3, b1, b2, coefp, coefn);
	//image_display(temp,h,w);
	gaussian_recursive_y(image, temp, w, h, a0, a1, a2, a3, b1, b2, coefp, coefn);
	//timer.fps_display();
	return(0);
}
void gaussian_recursive_x(float **od, float **id, int w, int h, float a0, float a1, float a2, float a3, float b1, float b2, float coefp, float coefn)
{
	//image_display(id,h,w);
	float xp = 0.0f;  // previous input
	float yp = 0.0f;  // previous output
	float yb = 0.0f;  // previous output by 2
	for (int y = 0; y < h; y++)
	{
		xp = id[y][0]; yb = coefp*xp; yp = yb;
		for (int x = 0; x < w; x++)
		{
			float xc = id[y][x];
			float yc = a0*xc + a1*xp - b1*yp - b2*yb;
			od[y][x] = yc;
			xp = xc; yb = yp; yp = yc;
		}
	}

	//image_display(od,h,w);
	// reverse pass
	// ensures response is symmetrical
	float xn = 0.f;
	float xa = 0.f;
	float yn = 0.f;
	float ya = 0.f;
	for (int y = 0; y < h; y++)
	{
		xn = xa = id[y][w - 1]; yn = coefn*xn; ya = yn;
		for (int x = w - 1; x >= 0; x--) {
			float xc = id[y][x];
			float yc = a2*xn + a3*xa - b1*yn - b2*ya;
			xa = xn; xn = xc; ya = yn; yn = yc;
			od[y][x] = od[y][x] + yc;
		}
	}
}
void gaussian_recursive_y(float **od, float **id, int w, int h, float a0, float a1, float a2, float a3, float b1, float b2, float coefp, float coefn)
{
	float xp = 0.0f;  // previous input
	float yp = 0.0f;  // previous output
	float yb = 0.0f;  // previous output by 2
	for (int x = 0; x < w; x++)
	{
		xp = id[0][x]; yb = coefp*xp; yp = yb;
		for (int y = 0; y < h; y++)
		{
			float xc = id[y][x];
			float yc = a0*xc + a1*xp - b1*yp - b2*yb;
			od[y][x] = yc;
			xp = xc; yb = yp; yp = yc;
		}
	}


	// reverse pass
	// ensures response is symmetrical
	float xn = 0.f;
	float xa = 0.f;
	float yn = 0.f;
	float ya = 0.f;
	for (int x = 0; x < w; x++)
	{
		xn = xa = id[h - 1][x]; yn = coefn*xn; ya = yn;
		for (int y = h - 1; y >= 0; y--)
		{
			float xc = id[y][x];
			float yc = a2*xn + a3*xa - b1*yn - b2*ya;
			xa = xn; xn = xc; ya = yn; yn = yc;
			od[y][x] = od[y][x] + yc;
		}
	}
}
int gaussian_recursive(float **image, float **temp, float sigma, int order, int h, int w)
{
	const float
		nsigma = sigma < 0.1f ? 0.1f : sigma,
		alpha = 1.695f / nsigma,
		ema = exp(-alpha),
		ema2 = exp(-2 * alpha),
		b1 = -2 * ema,
		b2 = ema2;
	float a0 = 0, a1 = 0, a2 = 0, a3 = 0, coefp = 0, coefn = 0;
	switch (order) {
	case 0: {
				const float k = (1 - ema)*(1 - ema) / (1 + 2 * alpha*ema - ema2);
				a0 = k;
				a1 = k*(alpha - 1)*ema;
				a2 = k*(alpha + 1)*ema;
				a3 = -k*ema2;
	} break;

	case 1: {
				const float k = (1 - ema)*(1 - ema) / ema;
				a0 = k*ema;
				a1 = a3 = 0;
				a2 = -a0;
	} break;

	case 2: {
				const float
					ea = exp(-alpha),
					k = -(ema2 - 1) / (2 * alpha*ema),
					kn = (-2 * (-1 + 3 * ea - 3 * ea*ea + ea*ea*ea) / (3 * ea + 1 + 3 * ea*ea + ea*ea*ea));
				a0 = kn;
				a1 = -kn*(1 + k*alpha)*ema;
				a2 = kn*(1 - k*alpha)*ema;
				a3 = -kn*ema2;
	} break;

	default:
		fprintf(stderr, "gaussianFilter: invalid order parameter!\n");
		return 0;
	}
	coefp = (a0 + a1) / (1 + b1 + b2);
	coefn = (a2 + a3) / (1 + b1 + b2);
	//timer.start();
	gaussian_recursive_x(temp, image, w, h, a0, a1, a2, a3, b1, b2, coefp, coefn);
	gaussian_recursive_y(image, temp, w, h, a0, a1, a2, a3, b1, b2, coefp, coefn);
	//timer.fps_display();
}
void qx_specular_free_image(unsigned char ***image_specular_free, unsigned char ***image_normalized, float **diffuse_chromaticity_max, int h, int w)
{
	int y, x;
	unsigned char *image_specular_free_x, *image_normalized_x; float *diffuse_chromaticity_max_x;
	unsigned char r, g, b; double imax, isum; float rf, gf, bf, c, t0, t1, t2, t3, diffuse, specular;
	//*image_sum_x,*image_max_x,*chromaticity_max_x,
	image_specular_free_x = image_specular_free[0][0];
	image_normalized_x = image_normalized[0][0];
	diffuse_chromaticity_max_x = diffuse_chromaticity_max[0];
	for (y = 0; y < h; y++)
	{
		for (x = 0; x<w; x++)
		{
			t1 = 3.f*(*diffuse_chromaticity_max_x++) - 1.f;
			t3 = 1.0f / 3.0f;
			r = (*image_normalized_x++);
			g = (*image_normalized_x++);
			b = (*image_normalized_x++);
			if (t1>0)
			{
				isum = r + g + b;
				if (isum == 0) c = 0;
				else
				{
					imax = max(max(r, g), b);
					c = (float)(imax / isum);
				}
				t0 = t1*c;
				if (fabs(t0) < QX_DEF_THRESHOLD_ZERO)
				{
					*image_specular_free_x++ = r;
					*image_specular_free_x++ = g;
					*image_specular_free_x++ = b;
				}
				else
				{
					t2 = (3.0f*c - 1.f);
					diffuse = float(imax*t2 / t0);
					specular = float(t3*(isum - diffuse));
					rf = r - specular;
					gf = g - specular;
					bf = b - specular;
					if (rf<0.f) rf = 0.f; else if (rf>255.f) rf = 255.f;
					if (gf<0.f) gf = 0.f; else if (gf>255.f) gf = 255.f;
					if (bf<0.f) bf = 0.f; else if (bf>255.f) bf = 255.f;
					*image_specular_free_x++ = unsigned char(rf + 0.5f);
					*image_specular_free_x++ = unsigned char(gf + 0.5f);
					*image_specular_free_x++ = unsigned char(bf + 0.5f);
				}
			}
			else
			{
				*image_specular_free_x++ = r;
				*image_specular_free_x++ = g;
				*image_specular_free_x++ = b;
			}
		}
	}
}
void qx_stereo_flip_corr_vol(double***corr_vol_right, double***corr_vol, int h, int w, int nr_plane, int offset)
{
	for (int y = 0; y < h; y++)
	{
		// the matching costs are equal for corr_vol_right[y][x][d] and corr_vol[y][x+d][d]
		for (int x = 0; x < w - nr_plane; x++) for (int d = offset; d < nr_plane; d++) corr_vol_right[y][x][d - offset] = corr_vol[y][x + d][d - offset];
		for (int x = w - nr_plane; x < w; x++) for (int d = offset; d < nr_plane; d++)
		{
			if ((x + d) < w) corr_vol_right[y][x][d - offset] = corr_vol[y][x + d][d - offset];
			else corr_vol_right[y][x][d - offset] = corr_vol_right[y][x][d - offset - 1];
		}
	}
}
void draw_slant(int* hist, float* slant, float*d0, int h, int w)
{
	IplImage* img = NULL;
	img = cvCreateImage(cvSize(w, h), 8, 1);
	for (int y = 0; y < h; y++)
	{
		for (int x = 0; x < w; x++)
		{
			if (slant[x + y * w])
				cvSet2D(img, y, x, cvScalar(0));
			else cvSet2D(img, y, x, cvScalar(255));
		}
	}
	cvNamedWindow("Image", 1);
	cvShowImage("Image", img);
	remove("img_slant.jpg");
	cvSaveImage("img_slant.jpg", img);
}
void read_outliers(unsigned char** mask_occlusion, int h, int w)
{
	memset(mask_occlusion[0], 0, sizeof(char)* h * w);
	//ifstream out1("D:\\Mid3\\Input\\Adirondack\\outlier_cross.txt");
	ifstream out1(outliers_path);
	// lua file
	int ccnt = ceil((float)w / (float)26);
	char str[100];
	int c1, c2;
	out1.getline(str, 100, '\n');
	for (int k = 0; k < ccnt; k++)
	{
		out1 >> str >> c1 >> str >> c2;
		for (int y = 0; y < h; y++)
		{
			for (int x = c1 - 1; x < c2; x++)
			{
				out1 >> mask_occlusion[y][x];
				mask_occlusion[y][x] -= '0';
			}
		}
		out1.getline(str, 100, '\n');
	}
}
void write_disparities(float* d, int h, int w, string filename)
{
	ofstream disp(filename);
	for (int y = 0; y < h; y++)
	{
		for (int x = 0; x < w; x++)
		{
			if (x == 1138 && y == 450)
				cout << "disp_n: " << d[x + y * w] << endl;
			disp << d[x + y * w] << " ";
		}
		disp << endl;
	}
	disp.close();
}
void read_disparities(float* d, int h, int w, string filename)
{
	char str[100];
	ifstream disp(filename);
	for (int y = 0; y < h; y++)
	{
		for (int x = 0; x < w; x++)
		{
			disp >> d[x + y * w];
		}
		disp.getline(str, 100, '\n');
	}
	disp.close();
}
void depth_best_cost(unsigned char**depth, double***evidence, int h, int w, int nr_planes, int offset)
{
	for (int y = 0; y < h; y++) 
	for (int x = 0; x < w; x++) 
	{ 
		/*if (x == 902 && y == 541)
		{
			for (int d = 0; d < nr_planes - offset; d++)
				cout << d << " " << evidence[y][x][d] << endl;
		}*/
		int d; vec_min_pos(d, evidence[y][x], nr_planes - offset); depth[y][x] = d + offset; 
	}
}
void depth_best_cost_f(float*depth, double***evidence, int h, int w, int nr_planes, int offset)
{
	for (int y = 0; y < h; y++)
	for (int x = 0; x < w; x++)
	{
		//int d; 
		//vec_min_pos(d, evidence[y][x], nr_planes - offset); 
		double min_val = evidence[y][x][0];
		int d = 0;
		for (int i = 1; i < nr_planes - offset; i++)
		{
			/*if (x == 661 && y == 7 && i == 32)
				cout << "gt: " << i << " " << evidence[y][x][i] << endl;*/
			if (evidence[y][x][i] < min_val)
			{
				min_val = evidence[y][x][i];
				d = i;
			}
		}	
		depth[x + y * w] = d + offset;
		/*if (x == 48 && y == 27)
		{
			cout << "min_d: " << depth[x + y * w] << endl;
			cout << depth[x + y * w] << " " << evidence[y][x][(int)depth[x + y * w]] << endl;
		}	*/
	}
}
void depth_best_cost_left_right(float*depth, int* l_left, int* l_right,
	int* r_left, int* r_right, double***evidence, int h, int w, int nr_planes, int offset)
{
	for (int y = 0; y < h; y++)
	for (int x = 0; x < w; x++)
	{
		//int d; 
		//vec_min_pos(d, evidence[y][x], nr_planes - offset); 
		if (x == 484 && y == 50)
		{
			cout << l_left[x + y * w] << " " << l_right[x + y * w] << endl;
			cout << r_left[x + y * w] << " " << r_right[x + y * w] << endl;
		}
		double min_val = evidence[y][x][0];
		double min_val_tmp = evidence[y][x][0];
		int d = 0;
		int d_tmp = 0;
		bool flag = false;
		for (int i = 1; i < nr_planes - offset; i++)
		{	
			float ratio1 = float(abs(x - l_right[x + y * w])) / (l_right[x + y * w] - l_left[x + y * w]);
			float ratio2 = float(abs(x - i - r_right[x + y * w])) / (r_right[x + y * w] - r_left[x + y * w]);
			float ratio3 = float(abs(x - l_left[x + y * w])) / (l_right[x + y * w] - l_left[x + y * w]);
			float ratio4 = float(abs(x - i - r_left[x + y * w])) / (r_right[x + y * w] - r_left[x + y * w]);
			if (x == 484 && y == 50 && (i == 45 || i == 70))
			{
				cout << ratio1 << " " << ratio2 << endl;
			}
			if (evidence[y][x][i] < min_val_tmp)
			{
				min_val_tmp = evidence[y][x][i];
				d_tmp = i;
			}
			if (evidence[y][x][i] < min_val)
			{		
				if (l_left[x + y * w] == 0 || r_left[x + y * w] == 0)
				{
					if (abs(ratio1 - ratio2) < 0.05)
					{
						min_val = evidence[y][x][i];
						d = i;
						flag = true;
					}
				}
				else if (l_right[x + y * w] == w - 1 || r_right[x + y * w] == w - 1)
				{
					if (abs(ratio3 - ratio4) < 0.05)
					{
						min_val = evidence[y][x][i];
						d = i;
						flag = true;
					}
				}
				else
				{
					if (abs(abs(x - l_left[x + y * w]) - abs(x - i - r_left[x + y * w])) < 0.05
						&& abs(abs(x - l_right[x + y * w]) - abs(x - i - r_right[x + y * w])) < 0.05)
					{
						min_val = evidence[y][x][i];
						d = i;
						flag = true;
					}
				}				
			}
		}
		if (flag)
			depth[x + y * w] = d + offset;
		else depth[x + y * w] = d_tmp + offset;
	}
}
void cost_fix(float*depth, int* l_left, int* l_right,
	int* r_left, int* r_right, double***evidence, int h, int w, int nr_planes, int offset)
{
	for (int y = 0; y < h; y++)
	for (int x = 0; x < w; x++)
	{
		if (x == 661 && y == 7)
		{
			cout << endl;
			cout << l_left[x + y * w] << " " << l_right[x + y * w] << endl;
			cout << r_left[x + y * w] << " " << r_right[x + y * w] << endl;
		}
		double min_val = evidence[y][x][0];
		double min_val_tmp = evidence[y][x][0];
		int d = 0;
		int d_tmp = 0;
		bool flag = false;
		for (int i = 1; i < nr_planes - offset; i++)
		{
			/*float ratio1 = float(abs(x - l_right[x + y * w])) / (l_right[x + y * w] - l_left[x + y * w]);
			float ratio2 = float(abs(x - i - r_right[x + y * w])) / (r_right[x + y * w] - r_left[x + y * w]);
			float ratio3 = float(abs(x - l_left[x + y * w])) / (l_right[x + y * w] - l_left[x + y * w]);
			float ratio4 = float(abs(x - i - r_left[x + y * w])) / (r_right[x + y * w] - r_left[x + y * w]);*/

			// ratio1, ratio3对于每个x来说为常量
			float ratio1 = float(x - l_right[x + y * w]);
			float ratio2 = float(x - i - r_right[x + y * w]);
			float ratio3 = float(x - l_left[x + y * w]);
			float ratio4 = float(x - i - r_left[x + y * w]);
			if (x == 661 && y == 7 && (i == 32 || i == 52))
			{
				cout << endl;
				cout << "ratio1: " << ratio1 << " ratio2 " << ratio2 << endl;
				cout << "ratio3: " << ratio3 << " ratio4 " << ratio4 << endl;
			}
			float conf_inv;
			if (l_left[x + y * w] == 0 || r_left[x + y * w] == 0)
			{
				if (ratio1 == 0) 
					ratio1 = 0.00001;
				if (ratio2 > 0)															// 和ratio4的符号相反
					conf_inv = 0;
				else
					conf_inv = abs(ratio1 - ratio2) / abs(ratio1);
			}
			else if (l_right[x + y * w] == w - 1 || r_right[x + y * w] == w - 1)
			{
				if (ratio3 == 0) 
					ratio3 = 0.00001;
				if (ratio4 < 0)
					conf_inv = 0;
				else
					conf_inv = abs(ratio3 - ratio4) / ratio3;			
			}
			else
			{
				if (ratio1 == 0) 
					ratio1 = 0.00001;
				if (ratio3 == 0)
					ratio3 = 0.00001;
				if (ratio2 > 0 || ratio4 < 0)
					conf_inv = 0;
				else
					conf_inv = (abs(ratio1 - ratio2) / ratio1 + abs(ratio3 - ratio4) / ratio3) / 2;
			}	
			// Vintage: 0.1
			//conf_inv = max(0.1, conf_inv);
			// Piano:
			conf_inv = max(0.1, conf_inv);
			evidence[y][x][i] *= (1 - exp(-conf_inv));
			if (x == 661 && y == 7 && (i == 32 || i == 52))
			{
				cout << endl;
				cout << "conf_inv: " << conf_inv << endl << "evidence: " << evidence[y][x][i] << endl;
			}
		}
	}
}
void disp_hist(int *hist, float* d0, int h, int w)
{
	memset(hist, 0, sizeof(int)* h * w);
	for (int y = 0; y < h; y++)
	for (int x = 0; x < w; x++)
	{
		hist[(int)d0[x + y * w]]++;
	}
}
void mismatch_clear(unsigned char** mask_occlusion, float* slant, int h, int w)
{
	int r = 2;
	int cnt;
	for (int y = 0; y < h; y++)
	{
		for (int x = 0; x < w; x++)
		{
			if (mask_occlusion[y][x] == 2)
			{
				cnt = 0;
				for (int yy = y - r; yy <= y + r; yy++)
				{
					for (int xx = x - r; xx <= x + r; xx++)
					{
						if (0 <= yy && yy < h && 0 <= xx && xx < w)
						{
							if (mask_occlusion[yy][xx] == 2)
							{
								cnt++;
							}
						}
					}
				}
				if (cnt < 10)
					mask_occlusion[y][x] = 0;
			}		
		}
	}
}
void slant_regions(unsigned char** mask_occlusion, float* slant, int h, int w)
{
	int r = 2;
	int flag;
	for (int y = 0; y < h; y++)
	{
		for (int x = 0; x < w; x++)
		{
			flag = 0;
			for (int yy = y - r; yy <= y + r; yy++)
			{
				for (int xx = x - r; xx <= x + r; xx++)
				{
					if (0 <= yy && yy < h && 0 <= xx && xx < w)
					{
						if (mask_occlusion[yy][xx] == 2)
						{
							//slant[x + y * w] = 1;
							flag = 2;
							//break;
						}
						else if (mask_occlusion[yy][xx] == 1)
						{
							flag = 1;
							slant[x + y * w] = 0;
							break;
						}
					}
				}
				//if (flag) break;
				if (flag == 1)
					break;
			}
			if (flag == 2)
				slant[x + y * w] = 1;
		}
	}
}
void select_disp(float** gradient, float* d0, float* dl, int h, int w, int nr_plane, int thre)
{
	int cnt = 0;
	for (int y = 0; y < h; y++)
	{
		for (int x = 0; x < w; x++)
		{
			if (x < nr_plane)
			{
				d0[x + y * w] = dl[x + y * w];
				continue;
			}
			if (gradient[y][x] > thre)
			{
				d0[x + y * w] = dl[x + y * w];
				cnt++;
			}
		}
	}
	cout << "local_ratio: " << (float)cnt / (w * h) << endl;
}
void disp_fusion(float** gradient, float* d0, float* dl, int h, int w, int nr_plane, int thre)
{
	int cnt = 0;
	for (int y = 0; y < h; y++)
	{
		for (int x = 0; x < w; x++)
		{
			if (x == 532 && y == 373)
			{
				cout << dl[x + y * w] << " " << d0[x + y * w] << endl;
				cout << gradient[y][x] << endl;
			}
				
			if (x < nr_plane)
			{			
				d0[x + y * w] = dl[x + y * w];
				continue;
			}		
			if (abs(d0[x + y * w] - dl[x + y * w]) <= 1)
			{
				d0[x + y * w] = (d0[x + y * w] + dl[x + y * w]) / 2;
				continue;
			}			
			if (gradient[y][x] > thre /*&& gradient[y][x] < 200*/)
			{				
				d0[x + y * w] = dl[x + y * w];
				cnt++;
			}
		}
	}
	//cout << "local_ratio: " << (float)cnt / (w * h) << endl;
}
void vec_min_pos(int &min_pos, double *in, int len)
{
	double min_val = in[0];
	min_pos = 0;
	for (int i = 1; i < len; i++) 
	if (in[i] < min_val)
	{
		min_val = in[i];
		min_pos = i;
	}
}
void qx_detect_occlusion_left_right(unsigned char**mask_left, unsigned char**depth_left, unsigned char**depth_right, int h, int w, int nr_plane)
{
	memset(mask_left[0], 0, sizeof(char)*h*w);
	for (int y = 0; y < h; y++)
	{
		for (int x = 0; x < w; x++)
		{
			int d = depth_left[y][x];
			int xr = x - d;
			if (xr >= 0)
			{
				if (d == 0 || abs(d - depth_right[y][xr]) >= 1)
				{
					//depth_left[y][x]=min(depth_left[y][x],depth_right[y][xr]);
					mask_left[y][x] = 255;
				}
			}
			else mask_left[y][x] = 255;
		}
	}
}
void qx_detect_occlusion_left_right1(unsigned char**mask_left, float*depth_left, float*depth_right, int h, int w, int nr_plane)
{
	memset(mask_left[0], 0, sizeof(char)*h*w);
	for (int y = 0; y < h; y++)
	{
		for (int x = 0; x < w; x++)
		{
			if (depth_left[x + y * w] > 0)
				int aa = 0;
			int d = depth_left[x + y * w];
			int xr = x - d;
			if (xr >= 0)
			{
				if (abs(d - depth_right[xr + y * w]) < 1.1)
					mask_left[y][x] = 0;
				else
				{
					mask_left[y][x] = 1;
					for (int d_tmp = 0; d_tmp < nr_plane; d_tmp++)
					{
						if (x - d_tmp >= 0 && abs(d_tmp - depth_right[x - d_tmp + y * w]) < 1.1)
						{
							mask_left[y][x] = 2;
							break;
						}
					}
				}
			}
			else mask_left[y][x] = 1;
		}
	}
}
bool cmp(float& a, float& b)
{
	return a < b;
}
//Ax+by+cz=D  
void cvFitPlane(const CvMat* points, float* plane){
	// Estimate geometric centroid.  
	int nrows = points->rows;
	int ncols = points->cols;
	int type = points->type;
	CvMat* centroid = cvCreateMat(1, ncols, type);
	cvSet(centroid, cvScalar(0));
	for (int c = 0; c<ncols; c++){
		for (int r = 0; r < nrows; r++)
		{
			centroid->data.fl[c] += points->data.fl[ncols*r + c];
		}
		centroid->data.fl[c] /= nrows;
	}
	// Subtract geometric centroid from each point.  
	CvMat* points2 = cvCreateMat(nrows, ncols, type);
	for (int r = 0; r<nrows; r++)
	for (int c = 0; c<ncols; c++)
		points2->data.fl[ncols*r + c] = points->data.fl[ncols*r + c] - centroid->data.fl[c];
	// Evaluate SVD of covariance matrix.  
	CvMat* A = cvCreateMat(ncols, ncols, type);
	CvMat* W = cvCreateMat(ncols, ncols, type);
	CvMat* V = cvCreateMat(ncols, ncols, type);
	cvGEMM(points2, points, 1, NULL, 0, A, CV_GEMM_A_T);
	cvSVD(A, W, NULL, V, CV_SVD_V_T);
	// Assign plane coefficients by singular vector corresponding to smallest singular value.  
	plane[ncols] = 0;
	for (int c = 0; c<ncols; c++){
		plane[c] = V->data.fl[ncols*(ncols - 1) + c];
		plane[ncols] += plane[c] * centroid->data.fl[c];
	}
	// Release allocated resources.  
	cvReleaseMat(&centroid);
	cvReleaseMat(&points2);
	cvReleaseMat(&A);
	cvReleaseMat(&W);
	cvReleaseMat(&V);
}
float* plane_fitting(float*d0, int* hist, int h, int w, int y, int x)
{
	float X_vector[100];
	float Y_vector[100];
	float Z_vector[100];
	int vals_size = 0;
	int r = 1;
	for (int yy = y - r; yy <= y + r; yy++)
	{
		for (int xx = x - r; xx <= x + r; xx++)
		{
			if (0 <= yy && yy < h && 0 <= xx && xx < w)
			{
				X_vector[vals_size] = xx;
				Y_vector[vals_size] = yy;
				Z_vector[vals_size++] = d0[xx + yy * w];
			}
		}
	}
	// plane fitting
	CvMat*points_mat = cvCreateMat(vals_size, 3, CV_32FC1);//定义用来存储需要拟合点的矩阵   
	for (int i = 0; i < vals_size; ++i)
	{
		points_mat->data.fl[i * 3 + 0] = X_vector[i];//矩阵的值进行初始化   X的坐标值  
		points_mat->data.fl[i * 3 + 1] = Y_vector[i];//  Y的坐标值  
		points_mat->data.fl[i * 3 + 2] = Z_vector[i];
	}
	float plane12[4] = { 0 };//定义用来储存平面参数的数组   
	cvFitPlane(points_mat, plane12);//调用方程   
	/*if (plane12[2] != 0)
		d0[x + y * w] = (plane12[3] - plane12[0] * x - plane12[1] * y) / plane12[2];*/
	if (plane12[2] == 0)
	{
		float l_tmp[3] = { 0 };
		float *l = l_tmp;
		return l;
	}
	float l_tmp[3] = { 0 };
	float *l = l_tmp;
	l[0] = -plane12[0] / plane12[2];
	l[1] = -plane12[1] / plane12[2];
	l[2] = plane12[3] / plane12[2];
	return l;
}
void interpolation(unsigned char**mask_left, float*depth_left, int h, int w)
{
	const float dir[] = 
	{
		0, 1,
		-0.5, 1,
		-1, 1,
		-1, 0.5,
		-1, 0,
		-1, -0.5,
		-1, -1,
		-0.5, -1,
		0, -1,
		0.5, -1,
		1, -1,
		1, -0.5,
		1, 0,
		1, 0.5,
		1, 1,
		0.5, 1
	};
	for (int y = 0; y < h; y++)
	{
		for (int x = 0; x < w; x++)
		{
			if (mask_left[y][x] > 0)
			{
				int j_left = x - 1;
				while (j_left >= 0 && mask_left[y][j_left] != 0) j_left--;
				int j_right = x + 1;
				while (j_right < w && mask_left[y][j_right] != 0) j_right++;
				if (j_left < 0)
				{
					depth_left[x + y * w] = depth_left[j_right + y * w];
					continue;
				}
				if (j_right >= w)
				{
					depth_left[x + y * w] = depth_left[j_left + y * w];
					continue;
				}
				else
				{
					depth_left[x + y * w] = min(depth_left[j_left + y * w], depth_left[j_right + y * w]);
				}

				/*if (j < 0)
				{
					j = x + 1;
					while (mask_left[y][j] != 0) j++;
				}*/
				
			}
			/*if (mask_left[y][x] == 1)
			{
				int j = x - 1;
				while (j >= 0 && mask_left[y][j] != 0) j--;
				if (j < 0)
				{
					j = x + 1;
					while (mask_left[y][j] != 0) j++;
				}
				depth_left[x + y * w] = depth_left[j + y * w];
			}*/
			//else if (mask_left[y][x] == 2)
			//{			
			//	vector<float> val;
			//	float vals[16];
			//	float X_vector[16];
			//	float Y_vector[16];
			//	int vals_size = 0;
			//	for (int d = 0; d < 16; d++) {
			//		float dx = dir[2 * d];
			//		float dy = dir[2 * d + 1];
			//		float xx = x;
			//		float yy = y;
			//		int xx_i = round(xx);
			//		int yy_i = round(yy);
			//		while (0 <= yy_i && yy_i < h && 0 <= xx_i && xx_i < w && mask_left[yy_i][xx_i] != 0) 
			//		{
			//			xx += dx;
			//			yy += dy;
			//			xx_i = round(xx);
			//			yy_i = round(yy);
			//		}
			//		int ind = yy_i * w + xx_i;
			//		if (0 <= yy_i && yy_i < h && 0 <= xx_i && xx_i < w) 
			//		{
			//			X_vector[vals_size] = xx_i;
			//			Y_vector[vals_size] = yy_i;
			//			vals[vals_size++] = depth_left[ind];
			//			val.push_back(depth_left[ind]);
			//		}
			//	}
			//	// plane fitting
			//	//CvMat*points_mat = cvCreateMat(vals_size, 3, CV_32FC1);//定义用来存储需要拟合点的矩阵   
			//	//for (int i = 0; i < vals_size; ++i)
			//	//{
			//	//	points_mat->data.fl[i * 3 + 0] = X_vector[i];//矩阵的值进行初始化   X的坐标值  
			//	//	points_mat->data.fl[i * 3 + 1] = Y_vector[i];//  Y的坐标值  
			//	//	points_mat->data.fl[i * 3 + 2] = vals[i];
			//	//}
			//	//float plane12[4] = { 0 };//定义用来储存平面参数的数组   
			//	//cvFitPlane(points_mat, plane12);//调用方程   
			//	//depth_left[x + y * w] = (plane12[3] - plane12[0] * x - plane12[1] * y) / plane12[2];

			//    sort(val.begin(), val.end(), cmp);
			//	depth_left[x + y * w] = val[vals_size / 2];
			//}

			/*if (x == 30 && y == 39)
				cout << "d_interpolation: " << depth_left[x + y * w] << endl;*/
		}
	}
}
void subpixel(double*** cost, float* d0, float* out, int h, int w, int disp_max, int offset)
{
	for (int y = 0; y < h; y++)
	{
		for (int x = 0; x < w; x++)
		{
			int id = x + y * w;
			int d = d0[id];
			out[id] = d;
			if (1 <= d && d < disp_max - 1) 
			{
				float cn = cost[y][x][d - 1];
				float cz = cost[y][x][d];
				float cp = cost[y][x][d + 1];
				float denom = 2 * (cp + cn - 2 * cz);
				if (denom > 1e-5) 
				{
					out[id] = d - min(1.0, max(-1.0, (cp - cn) / denom));
				}
			}
			if (x == 48 && y == 27)
				cout << "subpixel:" << d0[x + y * w] << endl;
		}
	}
}
int file_open_ascii(char *file_path, int *out, int len)
{
	FILE *file_in; char str[65]; int i;
	//file_in=fopen(file_path,"r");
	fopen_s(&file_in, file_path, "r");
	if (file_in != NULL)
	{
		fseek(file_in, 0, SEEK_SET);
		for (i = 0; i < len; i++)
		{
			//fscanf(file_in,"%s",str); 
			fscanf_s(file_in, "%s", str, 65);
			out[i] = atoi(str);
		}
		fclose(file_in);
	}
	else
	{
		printf("qx_basic_file: Can not open file: %s\n", file_path);
		getchar();
		exit(-1);
	}
	return(0);
}
float GetMedianNum(float* bArray, int iFilterLen)
{
	int i, j;
	float bTemp;

	//冒泡法
	for (j = 0; j < iFilterLen - 1; j++)
	{
		for (i = 0; i < iFilterLen - j - 1; i++)
		{
			if (bArray[i] > bArray[i + 1])
			{
				bTemp = bArray[i];
				bArray[i] = bArray[i + 1];
				bArray[i + 1] = bTemp;
			}
		}
	}

	if ((iFilterLen & 1) > 0)
	{
		//数组中有奇数个元素
		bTemp = bArray[(iFilterLen - 1) / 2];
	}
	else
	{
		bTemp = (bArray[(iFilterLen - 1) / 2] + bArray[iFilterLen / 2]) / 2;
	}

	return bTemp;
}
void MedianFilter(float* pImg1, float* pImg, int nWidth,     //pImg1 原图像
	int nHeight, int b)
{
	float* lpSrc;
	float* lpDst;
	float aValue[iFilterH * iFilterW];               // 指向滤波器数组的指针
	int i, j, k, l;
	int         lLineBytes;                         // 图像每行的字节数
	lLineBytes = nWidth * b;

	//median filter
	for (i = iFilterMY; i < nHeight - iFilterH + iFilterMY + 1; i++)
	{
		for (j = iFilterMX; j < nWidth - iFilterW + iFilterMX + 1; j++)
		{
			// 指向新DIB第i行，第j个象素的指针
			lpDst = pImg + lLineBytes * i + b * j;
			//RGB level

			for (int ib = 0; ib < b; ib++)
			{

				// 读取滤波器数组
				for (k = 0; k < iFilterH; k++)
				{
					for (l = 0; l < iFilterW; l++)
					{
						//(1,1)为像素中心点的相对位置
						lpSrc = pImg1 + lLineBytes * (i + (k - 1))
							+ b * (j + (l - 1)) + ib;

						aValue[k * iFilterW + l] = *lpSrc;
						//cout << aValue[k * iFilterW + l] << " ";
					}
				}

				*(lpDst + ib) = GetMedianNum(aValue, iFilterH * iFilterW);
			}
		}
	}

	//filling the rest of region
	for (i = 0; i < nHeight; i++)
	{
		for (j = 0; j < nWidth; j++)
		{
			if (i < iFilterH || i >= nHeight - iFilterH + iFilterMY + 1
				|| j < iFilterMX || j >= nWidth - iFilterW + iFilterMX + 1)
			{
				lpDst = pImg + lLineBytes * i + b * j;
				lpSrc = pImg1 + lLineBytes * i + b * j;
				for (int ib = 0; ib < b; ib++)
					*(lpDst + ib) = *(lpSrc + ib);              //purely copy the origin image
			}
		}
	}
}
void median(float* img, float* out, int height, int width, int kernel_radius)
{
	for (int y = 0; y < height; y++)
	{
		for (int x = 0; x < width; x++)
		{
			int id = x + y * width;
			float xs[11 * 11];
			int xs_size = 0;
			for (int xx = x - kernel_radius; xx <= x + kernel_radius; xx++) {
				for (int yy = y - kernel_radius; yy <= y + kernel_radius; yy++) {
					if (0 <= xx && xx < width && 0 <= yy && yy < height) {
						xs[xs_size++] = img[yy * width + xx];
					}
				}
			}
			sort(xs, xs + xs_size);
			out[id] = xs[xs_size / 2];
		}
	}
}
void bilateral(float* img, float* out, int h, int w, int kernel_radius, float sigma1, float sigma2)
{
	for (int y = 0; y < h; y++)
	{
		for (int x = 0; x < w; x++)
		{
			int id = x + y * w;

			float sum = 0;
			float cnt = 0;
			for (int i = -kernel_radius; i <= kernel_radius; i++) 
			{
				for (int j = -kernel_radius; j <= kernel_radius; j++) 
				{
					int yy = y + i;
					int xx = x + j;
					if (0 <= xx && xx < w && 0 <= yy && yy < h) 
					{
						float color_diff = img[yy * w + xx] - img[y * w + x];
						float v1 = exp(-(i * i + j * j) / (2 * sigma1 * sigma1));
						float v2 = exp(-(color_diff * color_diff) / (2 * sigma2 * sigma2));
						sum += img[yy * w + xx] * v1 * v2;
						cnt += v1 * v2;
					}
				}
			}
			out[id] = sum / cnt;
		}
	}
}
void disp_copy(float* src, float* dst, int h, int w)
{
	for (int y = 0; y < h; y++)
	for (int x = 0; x < w; x++)
		dst[x + y * w] = src[x + y * w];
}
void compute_error_rate(float* input, float* p_disp_gt, IplImage* msk, int h, int w)
{
	int cnt = 0;
	for (int y = 0; y < h; y++)
	{
		for (int x = 0; x < w; x++)
		{
			CvScalar s = cvGet2D(msk, y, x);
			if (s.val[0] == 128)
				continue;
			if (p_disp_gt[x + y * w] < 0 || p_disp_gt[x + y * w] > 1000)
				continue;
			if (abs(input[x + y * w] - p_disp_gt[x + y * w]) > 1)
			{
				cnt++;
			}
		
		}
	}
	ofstream err("err_rate.txt", ios::app);
	float err_rate = (float)cnt / (h * w);
	cout << "cnt: " << cnt << endl;
	cout << "error rate: " << err_rate << endl;
	err << err_rate << endl;
}
void draw_error_pixels(float* input, float* p_disp_gt, IplImage* msk, int h, int w, string mark)
{
	IplImage* img_err = NULL;
	img_err = cvCreateImage(cvSize(w, h), 8, 1);
	for (int y = 0; y < h; y++)
	{
		for (int x = 0; x < w; x++)
		{
			cvSet2D(img_err, y, x, cvScalar(255));
			CvScalar s = cvGet2D(msk, y, x);
			if (s.val[0] == 128)
				continue;
			if (p_disp_gt[x + y * w] < 0 || p_disp_gt[x + y * w] > 1000)
				continue;
			if (abs(input[x + y * w] - p_disp_gt[x + y * w]) > 1)
			{
				cvSet2D(img_err, y, x, cvScalar(0));
			}
		}
	}
	if (mark == "disp")
	{
		remove("img_err.jpg");
		cvSaveImage("img_err.jpg", img_err);
	}
	else if (mark == "cnn")
	{
		remove("img_err_cnn.jpg");
		cvSaveImage("img_err_cnn.jpg", img_err);
	}
	else if (mark == "local")
	{
		remove("img_l.jpg");
		cvSaveImage("img_l.jpg", img_err);
	}
	else if (mark == "nonlocal")
	{
		remove("img_n.jpg");
		cvSaveImage("img_n.jpg", img_err);
	}
}
void draw_differences(float* input1, float* input2, float* p_disp_gt, IplImage* msk, int h, int w)
{
	IplImage* img_err = NULL;
	img_err = cvCreateImage(cvSize(w, h), 8, 3);
	for (int y = 0; y < h; y++)
	{
		for (int x = 0; x < w; x++)
		{
			cvSet2D(img_err, y, x, cvScalar(0));
			CvScalar s = cvGet2D(msk, y, x);
			if (s.val[0] == 128)
				continue;
			if (p_disp_gt[x + y * w] < 0 || p_disp_gt[x + y * w] > 1000)
				continue;
			if (abs(input1[x + y * w] - p_disp_gt[x + y * w]) > 1
				&& abs(input2[x + y * w] - p_disp_gt[x + y * w]) <= 1)
			{
				input1[x + y * w] = input2[x + y * w];
				cvSet2D(img_err, y, x, cvScalar(255, 255, 0));
			}
			else if (abs(input1[x + y * w] - p_disp_gt[x + y * w]) <= 1
				&& abs(input2[x + y * w] - p_disp_gt[x + y * w]) > 1)
			{
				cvSet2D(img_err, y, x, cvScalar(0, 0, 255));
			}
		}
	}
	remove("img_diff.jpg");
	cvSaveImage("img_diff.jpg", img_err);
}
void draw_disparities(float*d, int h, int w, string name)
{
	IplImage* img = NULL;
	img = cvCreateImage(cvSize(w, h), 8, 1);
	for (int y = 0; y < h; y++)
	{
		for (int x = 0; x < w; x++)
			cvSet2D(img, y, x, cvScalar(d[x + y * w]));
	}
	if (name == "local")
	{
		//cvNamedWindow("Image", 1);
		//cvShowImage("Image", img);
		remove("local.jpg");
		cvSaveImage("local.jpg", img);
	}
	else if (name == "nonlocal")
	{
		remove("nonlocal.jpg");
		cvSaveImage("nonlocal.jpg", img);
	}
}

void draw_gradients(float** gradient, int h, int w)
{
	IplImage* img = NULL;
	img = cvCreateImage(cvSize(w, h), 8, 1);
	for (int y = 0; y < h; y++)
	{
		for (int x = 0; x < w; x++)
			cvSet2D(img, y, x, cvScalar(gradient[y][x]));
	}
	remove("gradient.jpg");
	cvSaveImage("gradient.jpg", img);
}